# MRM AI Platform - Cursor AI Rules

## üéØ Project Overview
Marketing Resource Management (MRM) platform with AI-first approach for advertising agencies.
- **Tech Stack:** Next.js 14, TypeScript, PostgreSQL, ClickHouse, Vector DB, Claude API
- **Architecture:** Microservices, Event-driven, AI Agents
- **Team:** 8-12 developers + 3-4 AI specialists
- **Primary Market:** Russia & CIS (–†–æ—Å—Å–∏—è –∏ –°–ù–ì)
- **Documentation Language:** Russian (–†—É—Å—Å–∫–∏–π)

---

## üåç –ö–†–ò–¢–ò–ß–ï–°–ö–ò –í–ê–ñ–ù–û: –Ø–∑—ã–∫ –∏ –ì–µ–æ–≥—Ä–∞—Ñ–∏—è

### 1. –û—Å–Ω–æ–≤–Ω–æ–π —è–∑—ã–∫ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏: –†–£–°–°–ö–ò–ô
**–í–°–ï–ì–î–ê –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ —Ä—É—Å—Å–∫–∏–π —è–∑—ã–∫ –¥–ª—è:**
- ‚úÖ –û–ø–∏—Å–∞–Ω–∏–π —Ñ—É–Ω–∫—Ü–∏–π –∏ –∫–æ–º–ø–æ–Ω–µ–Ω—Ç–æ–≤
- ‚úÖ –ö–æ–º–º–µ–Ω—Ç–∞—Ä–∏–µ–≤ –≤ –¥–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏–∏ (Markdown —Ñ–∞–π–ª—ã)
- ‚úÖ –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å—Å–∫–∏—Ö —Å–æ–æ–±—â–µ–Ω–∏–π –∏ UI —Ç–µ–∫—Å—Ç–æ–≤
- ‚úÖ –ü—Ä–∏–º–µ—Ä–æ–≤ –∏ —Å—Ü–µ–Ω–∞—Ä–∏–µ–≤ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—è
- ‚úÖ –ù–∞–∑–≤–∞–Ω–∏–π –∫–æ–º–ø–∞–Ω–∏–π, –±—Ä–µ–Ω–¥–æ–≤, –∫–∞–º–ø–∞–Ω–∏–π –≤ –ø—Ä–∏–º–µ—Ä–∞—Ö

**–ê–Ω–≥–ª–∏–π—Å–∫–∏–π –¥–æ–ø—É—Å—Ç–∏–º —Ç–æ–ª—å–∫–æ –¥–ª—è:**
- ‚ùå –ö–æ–¥ (–Ω–∞–∑–≤–∞–Ω–∏—è –ø–µ—Ä–µ–º–µ–Ω–Ω—ã—Ö, —Ñ—É–Ω–∫—Ü–∏–π, –∫–ª–∞—Å—Å–æ–≤)
- ‚ùå –¢–µ—Ö–Ω–∏—á–µ—Å–∫–∏–µ —Ç–µ—Ä–º–∏–Ω—ã (–µ—Å–ª–∏ –Ω–µ—Ç —É—Å—Ç–æ—è–≤—à–µ–≥–æ—Å—è —Ä—É—Å—Å–∫–æ–≥–æ —ç–∫–≤–∏–≤–∞–ª–µ–Ω—Ç–∞)
- ‚ùå –ù–∞–∑–≤–∞–Ω–∏—è —Ç–µ—Ö–Ω–æ–ª–æ–≥–∏–π –∏ –±–∏–±–ª–∏–æ—Ç–µ–∫
- ‚ùå API endpoints –∏ —Å—Ö–µ–º—ã –ë–î

**–ü—Ä–∏–º–µ—Ä—ã:**
```typescript
// ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–û: –∫–æ–¥ –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–æ–º, –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –Ω–∞ —Ä—É—Å—Å–∫–æ–º
/**
 * –ì–µ–Ω–µ—Ä–∏—Ä—É–µ—Ç –º–µ–¥–∏–∞–ø–ª–∞–Ω –Ω–∞ –æ—Å–Ω–æ–≤–µ –±—Ä–∏—Ñ–∞ –∫–ª–∏–µ–Ω—Ç–∞
 * 
 * @param brief - –ë—Ä–∏—Ñ –∫–ª–∏–µ–Ω—Ç–∞ —Å –±—é–¥–∂–µ—Ç–æ–º –∏ —Ü–µ–ª—è–º–∏
 * @returns –û–ø—Ç–∏–º–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –º–µ–¥–∏–∞–ø–ª–∞–Ω
 */
async function generateMediaPlan(brief: ClientBrief): Promise<MediaPlan> {
  // –ü—Ä–æ–≤–µ—Ä—è–µ–º –º–∏–Ω–∏–º–∞–ª—å–Ω—ã–π –±—é–¥–∂–µ—Ç
  if (brief.budget < MIN_BUDGET) {
    throw new ValidationError('–ë—é–¥–∂–µ—Ç –Ω–∏–∂–µ –º–∏–Ω–∏–º–∞–ª—å–Ω–æ–≥–æ –ø–æ—Ä–æ–≥–∞');
  }
  // ...
}

// ‚ùå –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û: –∫–æ–º–º–µ–Ω—Ç–∞—Ä–∏–∏ –Ω–∞ –∞–Ω–≥–ª–∏–π—Å–∫–æ–º
/**
 * Generates media plan based on client brief
 */
async function generateMediaPlan(brief: ClientBrief): Promise<MediaPlan> {
  // Check minimum budget
  if (brief.budget < MIN_BUDGET) {
    throw new ValidationError('Budget below minimum threshold');
  }
}
```

### 2. –ì–µ–æ–≥—Ä–∞—Ñ–∏—è: –†–æ—Å—Å–∏—è –∏ –°–ù–ì

**–í–°–ï–ì–î–ê –∏—Å–ø–æ–ª—å–∑—É–π—Ç–µ –ø—Ä–∏–º–µ—Ä—ã –∏–∑ —Ä–æ—Å—Å–∏–π—Å–∫–æ–≥–æ/–°–ù–ì —Ä—ã–Ω–∫–∞:**

‚úÖ **–ü–†–ê–í–ò–õ–¨–ù–û - –†–æ—Å—Å–∏–π—Å–∫–∏–µ –∫–æ–º–ø–∞–Ω–∏–∏ –∏ –±—Ä–µ–Ω–¥—ã:**
```typescript
// –ü—Ä–∏–º–µ—Ä—ã –∫–ª–∏–µ–Ω—Ç–æ–≤
const exampleClients = [
  '–°–±–µ—Ä–±–∞–Ω–∫',
  '–Ø–Ω–¥–µ–∫—Å',
  '–ì–∞–∑–ø—Ä–æ–º',
  '–ú–¢–°',
  '–ú–∞–≥–Ω–∏—Ç',
  'X5 Retail Group',
  '–¢–∏–Ω—å–∫–æ—Ñ—Ñ',
  '–í–ö–æ–Ω—Ç–∞–∫—Ç–µ',
  'Ozon',
  'Wildberries'
];

// –ü—Ä–∏–º–µ—Ä—ã –∞–≥–µ–Ω—Ç—Å—Ç–≤
const exampleAgencies = [
  'Realweb',
  'iConText',
  'Deltaplan',
  'Red Keds',
  'Grape',
  'Adventum'
];

// –ü—Ä–∏–º–µ—Ä—ã –ø–ª–æ—â–∞–¥–æ–∫
const platforms = [
  '–Ø–Ω–¥–µ–∫—Å –î–∏—Ä–µ–∫—Ç',
  'VK –†–µ–∫–ª–∞–º–∞',
  'myTarget',
  '–Ø–Ω–¥–µ–∫—Å –ú–µ—Ç—Ä–∏–∫–∞',
  'Telegram Ads'
];
```

‚ùå **–ù–ï–ü–†–ê–í–ò–õ–¨–ù–û - –ó–∞–ø–∞–¥–Ω—ã–µ –∫–æ–º–ø–∞–Ω–∏–∏:**
```typescript
// –ù–ï –ò–°–ü–û–õ–¨–ó–û–í–ê–¢–¨ –∑–∞–ø–∞–¥–Ω—ã–µ –ø—Ä–∏–º–µ—Ä—ã!
const exampleClients = [
  'Coca-Cola',    // ‚ùå
  'Nike',         // ‚ùå
  'Apple',        // ‚ùå
  'Salesforce',   // ‚ùå
  'HubSpot'       // ‚ùå
];
```

**–ì–µ–æ–≥—Ä–∞—Ñ–∏—è –≤ –ø—Ä–∏–º–µ—Ä–∞—Ö:**
```typescript
// ‚úÖ –ü–†–ê–í–ò–õ–¨–ù–û
const campaignExample = {
  client: '–°–±–µ—Ä–±–∞–Ω–∫',
  geo: ['–ú–æ—Å–∫–≤–∞', '–°–∞–Ω–∫—Ç-–ü–µ—Ç–µ—Ä–±—É—Ä–≥', '–ï–∫–∞—Ç–µ—Ä–∏–Ω–±—É—Ä–≥'],
  platforms: ['–Ø–Ω–¥–µ–∫—Å –î–∏—Ä–µ–∫—Ç', 'VK –†–µ–∫–ª–∞–º–∞'],
  budget: '‚ÇΩ5,000,000',  // –†—É–±–ª–∏!
  targetAudience: {
    age: [25, 45],
    interests: ['–±–∞–Ω–∫–æ–≤—Å–∫–∏–µ —É—Å–ª—É–≥–∏', '–∏–Ω–≤–µ—Å—Ç–∏—Ü–∏–∏']
  }
};

// ‚ùå –ù–ï–ü–†–ê–í–ò–õ–¨–ù–û
const campaignExample = {
  client: 'Bank of America',  // ‚ùå
  geo: ['New York', 'Los Angeles'],  // ‚ùå
  platforms: ['Google Ads', 'Facebook'],  // ‚ùå
  budget: '$50,000',  // ‚ùå –î–æ–ª–ª–∞—Ä—ã –≤–º–µ—Å—Ç–æ —Ä—É–±–ª–µ–π!
};
```

**–í–∞–ª—é—Ç–∞:**
- ‚úÖ –í—Å–µ–≥–¥–∞ —Ä—É–±–ª–∏: `‚ÇΩ`, `—Ä—É–±`, `—Ä—É–±–ª–µ–π`
- ‚ùå –ù–∏–∫–æ–≥–¥–∞: `$`, `‚Ç¨`, `dollars`, `euros`

**–ì–æ—Ä–æ–¥–∞:**
- ‚úÖ –ú–æ—Å–∫–≤–∞, –°–∞–Ω–∫—Ç-–ü–µ—Ç–µ—Ä–±—É—Ä–≥, –ï–∫–∞—Ç–µ—Ä–∏–Ω–±—É—Ä–≥, –ù–æ–≤–æ—Å–∏–±–∏—Ä—Å–∫, –ö–∞–∑–∞–Ω—å
- ‚ùå New York, London, Berlin, Paris

**–†–µ–∫–ª–∞–º–Ω—ã–µ –ø–ª–æ—â–∞–¥–∫–∏ (–ø—Ä–∏–æ—Ä–∏—Ç–µ—Ç):**
1. –Ø–Ω–¥–µ–∫—Å –î–∏—Ä–µ–∫—Ç (–Ω–µ Google Ads)
2. VK –†–µ–∫–ª–∞–º–∞ (–Ω–µ Facebook Ads)
3. myTarget
4. Telegram Ads
5. –Ø–Ω–¥–µ–∫—Å –ú–µ—Ç—Ä–∏–∫–∞ (–Ω–µ Google Analytics)

---

## üìã Core Principles

### 1. Context First
Always load relevant context before generating code:
- Current feature/module documentation
- Related existing code patterns
- RACI matrix for the workflow
- Integration requirements

### 2. Human-in-the-Loop
All AI-generated artifacts require human review:
- Code review by senior developer
- Functional testing by QA
- Business logic validation by PM/domain expert

### 3. Feedback Loop
Every interaction is learning opportunity:
- Track acceptance rate of AI suggestions
- Store feedback in vector DB
- Iterate on prompts based on data
- Measure and improve continuously

---

## üíª Code Style & Standards

### TypeScript
```typescript
// ‚úÖ Good: Explicit types, descriptive names
interface MediaPlanInput {
  clientId: string;
  budget: number;
  targetAudience: TargetAudience;
  objectives: CampaignObjective[];
}

// ‚ùå Bad: Any types, unclear names
function process(data: any): any {
  // ...
}

// ‚úÖ Good: Comprehensive JSDoc
/**
 * Generates media plan based on client brief and historical data
 * 
 * @param input - Client brief with budget and objectives
 * @param context - Historical campaigns for similar clients
 * @returns Optimized media plan with budget allocation
 * @throws {ValidationError} If budget < minimum threshold
 * 
 * @example
 * const plan = await generateMediaPlan({
 *   clientId: 'client-123',
 *   budget: 1000000,
 *   targetAudience: { age: [25, 45], interests: ['tech'] },
 *   objectives: ['awareness', 'conversions']
 * });
 */
async function generateMediaPlan(
  input: MediaPlanInput,
  context: HistoricalContext
): Promise<MediaPlan> {
  // Implementation
}
```

### React Components
```typescript
// ‚úÖ Good: Functional component with types
interface BriefFormProps {
  clientId: string;
  onSubmit: (brief: ClientBrief) => Promise<void>;
  onCancel: () => void;
}

export function BriefForm({ clientId, onSubmit, onCancel }: BriefFormProps) {
  // Use hooks, clear structure
  const [brief, setBrief] = useState<Partial<ClientBrief>>({});
  
  // Early returns for loading/error states
  if (loading) return <Skeleton />;
  if (error) return <ErrorMessage error={error} />;
  
  return (
    // JSX
  );
}

// ‚ùå Bad: Class component, no types
export class BriefForm extends React.Component {
  // Avoid class components
}
```

### File Naming
- Components: `PascalCase.tsx` (e.g., `MediaPlanGenerator.tsx`)
- Utilities: `camelCase.ts` (e.g., `budgetCalculator.ts`)
- Types: `PascalCase.types.ts` (e.g., `Campaign.types.ts`)
- Tests: `*.test.ts` or `*.spec.ts`

---

## ü§ñ AI Assistants Architecture

### Standard Pattern
```typescript
/**
 * Base class for all AI assistants in the platform
 * Implements feedback loop and context optimization
 */
abstract class AIAssistant<TInput, TOutput> {
  constructor(
    protected llm: LLMClient,
    protected contextManager: ContextManager,
    protected toolRegistry: ToolRegistry
  ) {}
  
  /**
   * Main entry point for assistant
   * Implements: context gathering ‚Üí prompt building ‚Üí LLM call ‚Üí post-processing
   */
  async process(input: TInput): Promise<TOutput> {
    // 1. Gather relevant context (max 100K tokens)
    const context = await this.contextManager.gather(input, {
      maxTokens: 100000,
      priority: ['current_task', 'project_data', 'historical_data']
    });
    
    // 2. Build optimized prompt
    const prompt = this.buildPrompt(input, context);
    
    // 3. Call LLM with tools
    const response = await this.llm.generate(prompt, {
      tools: this.getTools(),
      temperature: this.getTemperature(),
      maxTokens: 4096
    });
    
    // 4. Post-process and validate
    const output = await this.postProcess(response);
    
    // 5. Store for feedback loop
    await this.storeFeedback(input, output);
    
    return output;
  }
  
  protected abstract buildPrompt(input: TInput, context: Context): string;
  protected abstract postProcess(response: LLMResponse): Promise<TOutput>;
  protected abstract getTools(): Tool[];
}

/**
 * Example: Account Manager AI Assistant
 */
class AccountAssistant extends AIAssistant<ClientRequest, AccountResponse> {
  protected buildPrompt(request: ClientRequest, context: Context): string {
    return `
You are an AI assistant for Account Manager in advertising agency.

## Your Role
- Help with client communication
- Generate briefs and presentations
- Schedule meetings and follow-ups
- Maintain client relationships

## Current Context
Client: ${context.client.name}
Industry: ${context.client.industry}
History: ${context.previousProjects.length} projects, avg budget ${context.avgBudget}

## Current Request
${request.description}

## Instructions
1. Understand client needs thoroughly
2. Reference past successful projects
3. Propose actionable next steps
4. Be professional but friendly
5. Always include specific dates/numbers

Generate response in JSON format:
{
  "understanding": "your understanding of the request",
  "proposal": "your proposed action",
  "nextSteps": ["step 1", "step 2"],
  "timeline": "estimated timeline"
}
`;
  }
  
  protected getTools(): Tool[] {
    return [
      this.toolRegistry.get('client_database'),
      this.toolRegistry.get('calendar'),
      this.toolRegistry.get('email_composer')
    ];
  }
}
```

---

## üéØ RACI Implementation

### Always specify RACI for workflows
```typescript
interface Task {
  id: string;
  name: string;
  raci: {
    responsible: Role[];  // R - Who does the work
    accountable: Role;     // A - Who makes final decision (only one!)
    consulted: Role[];     // C - Who provides input
    informed: Role[];      // I - Who needs to know
  };
}

enum Role {
  ACCOUNT_MANAGER = 'account_manager',
  SPECIALIST = 'specialist',
  PROJECT_MANAGER = 'project_manager',
  STRATEGIST = 'strategist',
  CLIENT = 'client',
  // ... other roles
}

// Example: Brief creation workflow
const briefCreationTask: Task = {
  id: 'brief_creation',
  name: 'Create client brief',
  raci: {
    responsible: [Role.ACCOUNT_MANAGER],  // Does the work
    accountable: Role.PROJECT_MANAGER,     // Approves
    consulted: [Role.STRATEGIST, Role.CLIENT],
    informed: [Role.SPECIALIST]
  }
};
```

---

## üîß Context Optimization

### Priority Levels
```typescript
enum ContextPriority {
  CRITICAL = 0,   // Current task, client brief
  HIGH = 1,       // RACI matrix, workflow docs
  MEDIUM = 2,     // Historical data, similar projects
  LOW = 3         // General best practices, platform docs
}

class ContextManager {
  async gather(input: any, options: GatherOptions): Promise<Context> {
    const items: ContextItem[] = [];
    
    // 1. Critical: Always include (5-10K tokens)
    items.push(...await this.getCriticalContext(input));
    
    // 2. High: Include if space available (20-30K tokens)
    if (this.hasTokenBudget(items, options.maxTokens, 30000)) {
      items.push(...await this.getHighPriorityContext(input));
    }
    
    // 3. Medium: Include if space available (40-50K tokens)
    if (this.hasTokenBudget(items, options.maxTokens, 50000)) {
      items.push(...await this.getMediumPriorityContext(input));
    }
    
    // 4. Low: Fill remaining budget
    const remaining = options.maxTokens - this.countTokens(items);
    if (remaining > 10000) {
      items.push(...await this.getLowPriorityContext(input, remaining));
    }
    
    return this.buildContext(items);
  }
}
```

### Context Caching
```typescript
// Cache frequently used context to save tokens and time
const contextCache = new LRUCache<string, Context>({
  max: 100,
  ttl: 1000 * 60 * 30, // 30 minutes
});

// Cache keys examples:
// - `client:${clientId}` - client info
// - `workflow:${workflowType}` - RACI matrix
// - `template:${templateId}` - project template
```

---

## üß™ Testing Requirements

### Unit Tests
```typescript
// Every AI assistant function needs unit test
describe('AccountAssistant', () => {
  it('should generate brief from client request', async () => {
    const assistant = new AccountAssistant(mockLLM, mockContext, mockTools);
    const request = createMockClientRequest();
    
    const response = await assistant.process(request);
    
    expect(response).toMatchObject({
      understanding: expect.any(String),
      proposal: expect.any(String),
      nextSteps: expect.arrayContaining([expect.any(String)]),
      timeline: expect.any(String)
    });
  });
  
  it('should handle errors gracefully', async () => {
    const assistant = new AccountAssistant(mockFailingLLM, mockContext, mockTools);
    
    await expect(assistant.process({})).rejects.toThrow(ValidationError);
  });
});
```

### Integration Tests
```typescript
// Test full workflows with multiple components
describe('Brief Creation Workflow', () => {
  it('should complete full cycle: input ‚Üí AI ‚Üí human review ‚Üí output', async () => {
    const workflow = new BriefCreationWorkflow();
    
    // 1. Client submits request
    const requestId = await workflow.submitRequest(mockRequest);
    
    // 2. AI generates draft
    const draft = await workflow.generateDraft(requestId);
    expect(draft.status).toBe('pending_review');
    
    // 3. Human reviews and approves
    await workflow.review(draft.id, { approved: true, feedback: 'Good' });
    
    // 4. Final brief generated
    const final = await workflow.getFinalBrief(requestId);
    expect(final.status).toBe('approved');
  });
});
```

---

## üìä Error Handling

### Standard Error Types
```typescript
// Custom error classes for domain-specific errors
class ValidationError extends Error {
  constructor(message: string, public field: string) {
    super(message);
    this.name = 'ValidationError';
  }
}

class AIGenerationError extends Error {
  constructor(message: string, public context: any) {
    super(message);
    this.name = 'AIGenerationError';
  }
}

class RateLimitError extends Error {
  constructor(public retryAfter: number) {
    super(`Rate limit exceeded. Retry after ${retryAfter}s`);
    this.name = 'RateLimitError';
  }
}

// Always use try-catch with specific error handling
async function processWithAI(input: any): Promise<any> {
  try {
    const result = await aiAssistant.process(input);
    return result;
  } catch (error) {
    if (error instanceof ValidationError) {
      logger.warn('Validation failed', { field: error.field });
      throw new UserFacingError('Please check your input');
    }
    
    if (error instanceof RateLimitError) {
      logger.info('Rate limited, retrying...', { retryAfter: error.retryAfter });
      await sleep(error.retryAfter * 1000);
      return processWithAI(input); // Retry
    }
    
    if (error instanceof AIGenerationError) {
      logger.error('AI generation failed', { context: error.context });
      // Fallback to template or human intervention
      return fallbackHandler.handle(input);
    }
    
    // Unknown error
    logger.error('Unexpected error', { error });
    throw error;
  }
}
```

---

## üìù Documentation Standards

### README for each module
```markdown
# Account Assistant Module

## Purpose
AI-powered assistant for Account Managers to handle client communication and brief creation.

## Features
- Generate client briefs from conversations
- Schedule follow-ups automatically
- Maintain client relationship history
- Suggest upsell opportunities

## Usage
\`\`\`typescript
const assistant = new AccountAssistant(llm, context, tools);
const response = await assistant.process({
  clientId: 'client-123',
  request: 'Create brief for new campaign'
});
\`\`\`

## API
See [API.md](./API.md) for detailed API documentation.

## Testing
\`\`\`bash
npm test src/ai/assistants/account/
\`\`\`

## Feedback Loop
This assistant tracks:
- Acceptance rate (target: >80%)
- Edit distance (target: <20% of generated content)
- Time saved (target: 60min ‚Üí 10min per brief)

See metrics dashboard: /admin/ai/metrics/account-assistant
```

---

## üö´ Anti-Patterns (What NOT to Do)

### ‚ùå Don't: Trust AI blindly
```typescript
// BAD
const code = await ai.generate('Create user auth system');
await deployToProduction(code); // NO REVIEW!

// GOOD
const code = await ai.generate('Create user auth system');
await createPullRequest(code); // Human review required
```

### ‚ùå Don't: Overload context
```typescript
// BAD - loading entire codebase
const context = await loadAllFiles(); // 500K tokens!

// GOOD - selective context
const context = await loadRelevantFiles(task, { maxTokens: 100000 });
```

### ‚ùå Don't: Ignore TypeScript errors
```typescript
// BAD
const result = await someFunction(); // Type error! Ignoring...

// GOOD
const result: ExpectedType = await someFunction();
// Or fix the function signature
```

### ‚ùå Don't: Skip error handling
```typescript
// BAD
async function fetchData() {
  const data = await api.get('/data');
  return data;
}

// GOOD
async function fetchData(): Promise<Data> {
  try {
    const data = await api.get('/data');
    return data;
  } catch (error) {
    if (error instanceof NetworkError) {
      // Retry logic
    }
    throw new DataFetchError('Failed to fetch data', { cause: error });
  }
}
```

---

## üéì When to Ask for Human Help

AI should request human assistance when:
1. **Ambiguous requirements** - unclear what user wants
2. **Architectural decisions** - impacts multiple modules
3. **Breaking changes** - changes public APIs
4. **Security-sensitive code** - auth, payments, data access
5. **Performance-critical** - query optimization, caching strategy
6. **Business logic** - domain-specific rules
7. **RACI conflicts** - unclear who is accountable
8. **Budget decisions** - trade-offs between cost and quality

Example:
```typescript
if (requiresHumanDecision(task)) {
  await notifications.send({
    to: task.accountable,
    message: 'AI needs your input on: ' + task.name,
    priority: 'high'
  });
}
```

---

## üìà Metrics to Track

### Code Quality
- **Test Coverage:** Target 80%+
- **Type Coverage:** Target 95%+ (no `any` types)
- **Linter Errors:** Zero tolerance
- **Bundle Size:** Monitor and optimize

### AI Performance
- **Acceptance Rate:** % of AI suggestions accepted (target 75%+)
- **Edit Distance:** How much humans edit AI output (target <25%)
- **Time Saved:** Hours saved per week (target 20h+ per developer)
- **Bug Rate:** Bugs in AI code vs human code (should be similar or better)

### User Satisfaction
- **NPS Score:** For AI-assisted features (target 40+)
- **Task Completion Time:** With AI vs without (target 3x faster)
- **User Adoption:** % of team using AI tools (target 90%+)

---

## üîÑ Workflow Example

### Creating a new feature with AI

```
1. Read requirement
   ‚Üì
2. Search codebase for similar patterns
   ‚Üí `grep -r "similar_feature" src/`
   ‚Üì
3. Load relevant context (max 100K tokens)
   ‚Üí Current module docs
   ‚Üí Related interfaces
   ‚Üí RACI for this workflow
   ‚Üì
4. Generate code + tests
   ‚Üí Ask AI to implement
   ‚Üí Include error handling
   ‚Üí Add JSDoc comments
   ‚Üì
5. Run linters and tests
   ‚Üí `npm run lint`
   ‚Üí `npm test`
   ‚Üì
6. Human review
   ‚Üí Code review by senior
   ‚Üí Test execution by QA
   ‚Üì
7. Iterate based on feedback
   ‚Üí Address review comments
   ‚Üí Improve prompts for next time
   ‚Üì
8. Commit with descriptive message
   ‚Üí `git commit -m "feat(account): add AI brief generator"`
   ‚Üì
9. Update metrics dashboard
   ‚Üí Log time saved
   ‚Üí Log acceptance rate
   ‚Üí Store feedback
```

---

## üéØ Prompting Best Practices

### Be Specific
```
‚ùå "Create a form"
‚úÖ "Create a TypeScript React form component for client brief input with:
   - Fields: company name, industry, budget, objectives
   - Validation: Zod schema
   - Submit: async POST to /api/briefs
   - Error handling: toast notifications
   - Accessibility: ARIA labels"
```

### Provide Context
```
‚ùå "Fix this bug"
‚úÖ "Fix this bug in AccountAssistant.ts line 45:
   Error: TypeError: Cannot read property 'name' of undefined
   Context: This happens when client object is missing from context
   Expected: Should handle missing client gracefully
   Related code: ClientContext.ts, ContextManager.ts"
```

### Request Tests
```
‚ùå "Create a function to calculate budget"
‚úÖ "Create a function to calculate budget allocation across channels:
   - Input: total budget, channel weights
   - Output: budget per channel
   - Include: unit tests, edge cases (0 budget, negative, etc)
   - Use: TypeScript, strict mode"
```

---

## üèÅ Quick Reference

### Common Commands
```bash
# Start development
npm run dev

# Run tests
npm test

# Type check
npm run type-check

# Lint code
npm run lint

# Format code
npm run format

# Build for production
npm run build

# Run AI metrics dashboard
npm run ai:metrics
```

### Project Structure
```
mrm-ai/
‚îú‚îÄ‚îÄ src/
‚îÇ   ‚îú‚îÄ‚îÄ ai/                  # AI assistants and agents
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ assistants/      # Domain-specific assistants
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ agents/          # Autonomous agents
‚îÇ   ‚îÇ   ‚îú‚îÄ‚îÄ prompts/         # Prompt library
‚îÇ   ‚îÇ   ‚îî‚îÄ‚îÄ tools/           # AI tools (API wrappers)
‚îÇ   ‚îú‚îÄ‚îÄ features/            # Feature modules
‚îÇ   ‚îú‚îÄ‚îÄ shared/              # Shared utilities
‚îÇ   ‚îî‚îÄ‚îÄ types/               # TypeScript types
‚îú‚îÄ‚îÄ prompts/                 # Prompt templates
‚îú‚îÄ‚îÄ context/                 # Context for AI
‚îú‚îÄ‚îÄ tests/                   # Test files
‚îî‚îÄ‚îÄ docs/                    # Documentation
```

---

**Version:** 1.0  
**Last Updated:** 2025-10-23  
**Maintainer:** MRM AI Team

